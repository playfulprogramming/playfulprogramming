---
import { getUnicornsByLang } from "../../utils/api";
import { getInitialItems } from "./get-involved-header";
import style from "./get-involved-header.module.scss";
import Hr from "./hr.astro";
import { Button } from "components/index";

const NUMBER_OF_INNER_ITEMS = 22;
const NUMBER_OF_OUTER_ITEMS = 28;
const INNER_OFFSET = 150;
const OUTER_OFFSET = 300;

// We return percentages to use in initial (no JS) left/top, but then the problem
// Is that left/top are aligned to the pixel-subgrid, which causes headaches
// With the animation causing "wobbles".
const initialInnerItems = getInitialItems(NUMBER_OF_INNER_ITEMS, INNER_OFFSET);
const initialOuterItems = getInitialItems(NUMBER_OF_OUTER_ITEMS, OUTER_OFFSET);

const unicorns = getUnicornsByLang("en");
const reverseUnicorns = unicorns.slice().reverse();

const getSafeIndex = <T,>(array: T[], index: number) => {
	return array[index % array.length];
};
---

<section class={style.headerContainer}>
	<div class={style.getInvolvedContainer}>
		<div class={style.getInvolvedContents}>
			<img
				src="/flair/star.svg"
				alt=""
				class={style.starFlair}
				aria-hidden="true"
			/>
			<img
				src="/flair/pink_bowtie.svg"
				alt=""
				class={style.bowtieFlair}
				aria-hidden="true"
			/>
			<h1 class={style.getInvolvedHeader}>Join us!</h1>
			<div class={style.break}>
				<Hr />
			</div>
			<p class={`text-style-headline-6 ${style.paragraph}`}>
				Unicorn Utterances embraces the best part of Open Source: Weâ€™re ran by
				real people wanting to make an impact in the world and help others learn
				and join us along the journey.
			</p>
			<Button tag="button" class={style.playPauseBtn} id="carousel-play-pause"
				>Pause</Button
			>
		</div>
		<div class={style.innerInvolvedContainer} id="inner-circle-container">
			{
				initialInnerItems.map((item, index) => {
					const unicorn = getSafeIndex(unicorns, index);
					return (
						<div
							data-is-circle-inner-item
							id={`circle-item-inner-${index}`}
							class={style.circleItem}
							style={{
								left: item.x,
								top: item.y,
							}}
						>
							<div
								class={style.inner}
								style={{
									backgroundImage: `url(${encodeURI(unicorn.profileImgMeta.relativeServerPath)})`,
									transform: `scale(${item.scale})`,
								}}
							>
								{unicorn.roles[0] && (
									<img
										class={style.stickerRole}
										src={`/stickers/role_${unicorn.roles[0]}.svg`}
										alt=""
									/>
								)}
							</div>
						</div>
					);
				})
			}
		</div>
		<div class={style.outerInvolvedContainer} id="outer-circle-container">
			{
				initialOuterItems.map((item, index) => {
					const unicorn = getSafeIndex(reverseUnicorns, index);
					return (
						<div
							data-is-circle-outer-item
							id={`circle-item-outer-${index}`}
							class={style.circleItem}
							style={{
								left: item.x,
								top: item.y,
							}}
						>
							<div
								class={style.inner}
								style={{
									backgroundImage: `url(${encodeURI(unicorn.profileImgMeta.relativeServerPath)})`,
									transform: `scale(${item.scale})`,
								}}
							>
								{unicorn.roles[0] && (
									<img
										class={style.stickerRole}
										src={`/stickers/role_${unicorn.roles[0]}.svg`}
										alt=""
									/>
								)}
							</div>
						</div>
					);
				})
			}
		</div>
	</div>
</section>

<script>
	// In a requestAnimationFrame loop, take each item and change the X, Y, and scale to rotate the items in the circle clockwise
	import { getInitialItems, calculatePosition } from "./get-involved-header";

	const DECELERATION_RATE = 0.99;
	const MIN_SPEED_THRESHOLD = 0.0001;
	const INNER_CIRCLE_ROTATION_SPEED = 0.001;
	const OUTER_CIRCLE_ROTATION_SPEED = 0.0005;
	const SPEED_CALCULATION_FACTOR = 0.01;
	const OUTER_SPEED_MULTIPLIER = 0.5;
	const INNER_OFFSET = 150;
	const OUTER_OFFSET = 300;

	const innerCircle = Array.from(
		document.querySelectorAll("[data-is-circle-inner-item]"),
	) as HTMLElement[];
	const outerCircle = Array.from(
		document.querySelectorAll("[data-is-circle-outer-item]"),
	) as HTMLElement[];
	const innerContainer = document.querySelector(
		"#inner-circle-container",
	) as HTMLElement;
	const outerContainer = document.querySelector(
		"#outer-circle-container",
	) as HTMLElement;
	const playPauseBtn = document.querySelector(
		"#carousel-play-pause",
	) as HTMLElement;

	let innerAngle = 0;
	let outerAngle = 0;
	// Is the user currently dragging the mouse/touch?
	let shouldUpdate = true;
	// Does the user have `prefers-reduced-motion` enabled?
	let noMotion = false;
	// Has the user explicitly paused using the button?
	let paused = false;
	// The previous X coord for the mouse/touch movement
	let prevX = 0;
	// The speed of which to move the icons left/right when dragging, used for momentum
	let speed = 0;
	// Is decelerating from a mouse/touch drag?
	let decelerating = false;

	function calculateSpeed(e: MouseEvent | TouchEvent) {
		const isMouseEvent = (e: any): e is MouseEvent => {
			return "clientX" in e;
		};
		const currentX = isMouseEvent(e) ? e.clientX : e.touches[0].clientX;
		if (prevX === 0) prevX = currentX;
		const diff = currentX - prevX;
		speed = diff * SPEED_CALCULATION_FACTOR;
		prevX = currentX;
	}

	function onMouseMove(e: MouseEvent) {
		calculateSpeed(e);
		innerAngle -= speed;
		outerAngle -= speed * OUTER_SPEED_MULTIPLIER;
		redraw();
	}

	function onTouchMove(e: TouchEvent) {
		calculateSpeed(e);
		innerAngle -= speed;
		outerAngle -= speed * OUTER_SPEED_MULTIPLIER;
		redraw();
	}

	function startDeceleration() {
		if (speed !== 0) {
			decelerating = true;
			requestAnimationFrame(decelerate);
		}
	}

	function decelerate() {
		if (!decelerating || noMotion || paused) return;
		innerAngle -= speed;
		outerAngle -= speed * OUTER_SPEED_MULTIPLIER;
		redraw();
		speed *= DECELERATION_RATE;
		if (Math.abs(speed) < MIN_SPEED_THRESHOLD) {
			decelerating = false;
			speed = 0;
		} else {
			requestAnimationFrame(decelerate);
		}
	}

	let innerContainerSize = innerContainer.getBoundingClientRect();
	let outerContainerSize = outerContainer.getBoundingClientRect();
	document.addEventListener("resize", () => {
		innerContainerSize = innerContainer.getBoundingClientRect();
		outerContainerSize = outerContainer.getBoundingClientRect();
	});

	function redraw() {
		innerCircle.forEach((element: HTMLElement, index) => {
			const { x, y, scale } = calculatePosition(
				innerCircle.length,
				index + innerAngle,
				INNER_OFFSET,
			);

			// x and y are percentages (EG: 80.51) of the container size
			const newX = innerContainerSize.width * (x / 100);
			const newY = innerContainerSize.height * (y / 100);
			element.style.transform = `translate(${newX}px, ${newY}px)`;
			element.style.left = "0";
			element.style.top = "0";
			(element.children[0] as HTMLElement).style.transform = `scale(${scale})`;
		});

		outerCircle.forEach((element: HTMLElement, index) => {
			const { x, y, scale } = calculatePosition(
				outerCircle.length,
				index + outerAngle,
				OUTER_OFFSET,
			);

			// x and y are percentages (EG: 80.51) of the container size
			const newX = outerContainerSize.width * (x / 100);
			const newY = outerContainerSize.height * (y / 100);
			element.style.transform = `translate(${newX}px, ${newY}px)`;
			element.style.left = "0";
			element.style.top = "0";
			(element.children[0] as HTMLElement).style.transform = `scale(${scale})`;
		});
	}

	function update() {
		if (!shouldUpdate || noMotion || paused) return;
		innerAngle += INNER_CIRCLE_ROTATION_SPEED;
		outerAngle += OUTER_CIRCLE_ROTATION_SPEED;
		redraw();
		requestAnimationFrame(update);
	}

	function setupEventListeners() {
		// If prefers-reduced-motion is enabled, stop the animation
		const mediaQuery = window.matchMedia("(prefers-reduced-motion: reduce)");
		mediaQuery.addEventListener("change", (e) => {
			if (e.matches) {
				noMotion = true;
				playPauseBtn.ariaHidden = `true`;
			} else {
				noMotion = false;
				playPauseBtn.ariaHidden = `false`;
			}
			update();
		});
		noMotion = mediaQuery.matches;
		playPauseBtn.ariaHidden = `${noMotion}`;

		playPauseBtn.addEventListener("click", () => {
			paused = !paused;
			playPauseBtn.children[0].textContent = paused ? "Play" : "Pause";
			update();
		});

		function handleDragStart(e: MouseEvent | TouchEvent) {
			if (paused) return;
			shouldUpdate = false;
			if (e.type === "mousedown") {
				document.addEventListener("mousemove", onMouseMove);
			} else if (e.type === "touchstart") {
				document.addEventListener("touchmove", onTouchMove);
			}
		}

		function handleDragEnd() {
			document.removeEventListener("mousemove", onMouseMove);
			document.removeEventListener("touchmove", onTouchMove);
			prevX = 0;
			if (!shouldUpdate) {
				shouldUpdate = true;
				update();
			}
		}

		function setupContainerListeners(container: HTMLElement) {
			container.addEventListener("touchstart", handleDragStart);
			container.addEventListener("mousedown", handleDragStart);
		}

		document.addEventListener("mouseup", startDeceleration);
		document.addEventListener("touchend", startDeceleration);
		document.addEventListener("mouseup", handleDragEnd);
		document.addEventListener("touchend", handleDragEnd);

		return {
			setupContainerListeners,
		};
	}

	// Setup event listeners
	const { setupContainerListeners } = setupEventListeners();
	setupContainerListeners(innerContainer);
	setupContainerListeners(outerContainer);

	// Start the event loop
	update();
</script>
